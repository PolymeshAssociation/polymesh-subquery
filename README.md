[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)
[![Github Actions Workflow](https://github.com/PolymeshAssociation/polymesh-subquery/actions/workflows/main.yml/badge.svg)](https://github.com/PolymeshAssociation/polymesh-subquery/actions)
[![Sonar Status](https://sonarcloud.io/api/project_badges/measure?project=PolymeshAssociation_polymesh-subquery&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=PolymeshAssociation_polymesh-subquery)
[![Issues](https://img.shields.io/github/issues/PolymeshAssociation/polymesh-subquery)](https://github.com/PolymeshAssociation/polymesh-subquery/issues)

# Polymesh Subquery

This project has been initially created to replace [the harvester](https://github.com/PolymathNetwork/polkascan-pre-harvester) meaning the output of both should match as much as possible, however since the harvester serializes chain objects in slightly different ways than polkadot-js, this project contains a list of special cases handled both at the initial deserialization level (in [project.yaml](project.yaml).network.types) and at the serialization level in [serializeLikeHarvester.ts](src/mappings/serializeLikeHarvester.ts).

## Running

1. Set the chain endpoint in [project.template.yaml](project.template.yaml).network.endpoint.
2. Set the starting block in [project.template.yaml](project.template.yaml).dataSources.main.startingBlock (this repo has been designed to work from the start of spec version 2021, aka block 1187881)
3. Install subql cli: `npm i -g @subql/cli`
4. `rerun.sh` (requires docker compose)

## Using event_arg_x indexes.

The event_arg_x columns are now text, in order for them to fit in BTree indexes they are truncated to 100 characters like in the harvester.
This means that if you want to take advantage of the index in your query, you must use an expression like: `WHERE left(event_arg_x, 100) = 'foobar'`.
Otherwise using `WHERE event_arg_x = 'foobar'` will result in a full table scan.

## Debugging using the found_types table

The found_types table generated by subquery contains all types that have been serialized like the harvester, the actual type is in column ID which is the primary key and therefore unique and the raw type is in the raw_type column, if things break this is the first place to look for potential mismatches between types.

## Version

This SubQuery version works with chain version 4.1.1
